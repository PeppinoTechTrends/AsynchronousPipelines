

# AsynchronousServerClientLib - Overview
The **AsynchronousServerClientLib** is a powerful library for managing asynchronous communication between clients and servers. With this library, developers can easily create applications that are able to handle multiple client connections and provide fast, asynchronous communication between clients and servers.

 **Getting Start with Server**


`Listener` is a class that serves as a starting point for setting up server-client communication in the network. It is responsible for managing the creation and management of the server socket channel and the incoming client socket channels.

    // Get the instance of the Listener Class
     Listener listener = Listener.getInstance();

The `startListen` method in the `Listener` class is responsible for starting the listening process on a specific socket channel.

The method takes two parameters: a `serverSocketChannel` and a `callback` function.
The `serverSocketChannel` is an asynchronous socket channel that is used as a server-side socket to listen for incoming connections.
The `callback` function is executed whenever a new client connects to the server. This function is called for each connected client and is passed the `socketChannel` of the newly connected client.
In the `startListen` method, the server socket channel is set up to continuously listen for incoming connections. When a new client connects, the server socket channel returns the client's socket channel and the `callback` function is executed.

    listener.startConnectionListen(serverSocketChannel, socketChannel ->{
    //Input from Clients
    }
   
   
```sh
// Create a new InputListener to handle the ServerSocket input
InputListener inputListener = new InputListener(socketChannel, allocateDirect, minBuffer, maxBuffer, responseCallback);
```

`InputListener` is a class used to handle input coming from a socket. When creating a server socket, it's necessary for the server to be able to listen for connecting clients and handle the data sent by them. The InputListener class provides a way to do this, as it allows defining how to handle incoming data. In particular, the InputListener class implements the CompletionHandler interface, which is used to handle data asynchronously.

When a client sends data to the server, the data is read and handled by a CompletionHandler, which can be an instance of the InputListener class. InputListener defines a `handle` method, which is called every time a client sends data to the server. In this method, it's possible to define the logic to use for handling incoming data.
 ```sh
// Create an output listener to handle the server responses  
OutputListener listener = new OutputListener(socketChannel, initBuffer, allocateDirect);
 ```
`OutputEventHandler` is a class used to handle output events generated by the server or client in a network application. The class is used to send data from the server or client to a recipient, such as another client or a storage device.

In particular, the OutputEventHandler class provides a way to handle asynchronously the output data generated by an instance of `AsynchronousSocketChannel`, which represents an asynchronous network socket. The class implements the `CompletionHandler` interface, which enables efficient handling of asynchronous output.

The `handle` method implemented by the class is called when the asynchronous output operation has been completed. In this method, it is possible to define the logic that you want to use to handle the output generated by the server or client, for example, to write the data to another socket or to save it to a storage device.

**Code example Server complete**
 ```sh
/**
 * This Java class sets up a server that listens for incoming connections and handles them by creating an input listener
 * that decodes received objects into User objects using ObjectUtils.byteArrayToObject() or print other value.
 * <p>
 * The main method sets up the server and starts listening for incoming connections.
 * It creates an input listener for each new connection and starts it.
 * The input listener uses a ResponseCallback to handle successful or failed input reception.
 * <p>
 * The createInputListenerResponseCallback() method returns a ResponseCallback that handles the reception of User objects by decoding them and printing their age and UUID.
 * In case of any exceptions, the method prints the error message and closes the socket connection using the AsyncSocket.closeSocketChannel() method.
 */
public class TestServer {
  public static void main(String[] args) {

    try {
      AsynchronousServerSocketChannel serverSocketChannel = AsyncServerSocket.createServer(new InetSocketAddress(8080));

      Listener.getInstance().startConnectionListen(serverSocketChannel, socketChannel -> {
        System.out.println("Client Connected");
        InputListener inputListener = new InputListener(socketChannel, true, 1024, 4192, createInputListenerResponseCallback(socketChannel));
        inputListener.start();
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
          System.out.println("Server shutdown");
          inputListener.close();
        }));
      });
    } catch (IOException e) {
      System.err.println("Error while starting server: " + e.getMessage());
    }
  }

  private static ResponseCallback createInputListenerResponseCallback(AsynchronousSocketChannel socketChannel) {
    return new ResponseCallback() {
      @Override
      public void complete(Object o) {
        try {
          if (o instanceof byte[] object) {
            Human user = (Human) ObjectUtils.byteArrayToObject(object);
            System.out.println("User detected!");
            System.out.println("AGE: " + user.getAge());
            System.out.println("UUID: " + user.getUuid().toString());
          } else {
            System.out.println(o);
          }
        } catch (IOException | ClassNotFoundException e) {
          System.err.println("Error while decoding object: " + e.getMessage());
          AsyncSocket.closeSocketChannel(socketChannel);
        }

      }

      @Override
      public void completeExceptionally(Throwable throwable) {
        System.err.println("Error while receiving input: " + throwable.getMessage());
        AsyncSocket.closeSocketChannel(socketChannel);
      }
    };
  }
}
```

**Getting Start with Client**

`AsyncSocket` is a class that provides a static method for creating a client connection using an AsynchronousSocketChannel. The main purpose of this class is to simplify the process of creating a client connection for a client application that wants to communicate with a server.

The `createClient` method is the main method of this class. It takes an `InetSocketAddress` as an input, which represents the address and port of the server that the client wants to connect to. The method opens an AsynchronousSocketChannel and connects to the specified server. The method returns the connected AsynchronousSocketChannel.

The method also throws IOException, ExecutionException, and InterruptedException if an I/O error occurs or if the current thread was interrupted while waiting for the connection to complete.

This method provides a convenient way for clients to connect to a server, without having to worry about the underlying details of opening and connecting a socket channel.
```sh
AsynchronousServerSocketChannel serverSocketChannel = AsyncServerSocket.createServer(new InetSocketAddress(8080));  
```


Code example client with multi output:

```sh
/**
 * The TestClientMultiThread class creates a client that connects to a server at localhost:8080 using the AsyncSocket class.
 * <p>
 * It then creates single thread that send string values to the server using an OutputListener.
 * Each thread sends a different number of values at different time intervals.
 * The ResponseCallback interface is implemented to handle success and failure for each of the values sent.
 * <p>
 * The createResponseCallback method returns a new instance of ResponseCallback with a custom implementation for success and failure.
 * The sleep method is used to delay the sending of values in each thread.
 * <p>
 * The class is intended to demonstrate how to use the OutputListener class in a multi-threaded environment to send data to a server asynchronously.
 */

public class TestClientSingleThread {

  public static void main(String[] args) {
    try {
      AsynchronousSocketChannel socketChannel = AsyncSocket.createClient(new InetSocketAddress("localhost", 8080));
      OutputListener listener = new OutputListener(socketChannel, 2048, true);

      for (int i = 0; i < 500; i++) {
        String message = "Test".concat(String.valueOf(i));
        System.out.println(message);
        listener.sendStringSanitized(message, new ResponseCallback() {
          @Override
          public void complete(Object o) {
            System.out.println("SUCCESS");
          }

          @Override
          public void completeExceptionally(Throwable throwable) {
            System.out.println("FAILED");
          }
        });
        Thread.sleep(30);
      }
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
} catch (IOException | ExecutionException | InterruptedException e) {
  e.printStackTrace();
}
```

 TODO:
 - Implement security procotol




# AsynchronousServerClientLib - Overview
The **AsynchronousServerClientLib** is a powerful library for managing asynchronous communication between clients and servers. With this library, developers can easily create applications that are able to handle multiple client connections and provide fast, asynchronous communication between clients and servers.

 **Getting Start with Server**


`Listener` is a class that serves as a starting point for setting up server-client communication in the network. It is responsible for managing the creation and management of the server socket channel and the incoming client socket channels.

    // Get the instance of the Listener Class
     Listener class Listener listener = Listener.getInstance();

The `startListen` method in the `Listener` class is responsible for starting the listening process on a specific socket channel.

The method takes two parameters: a `serverSocketChannel` and a `callback` function.
The `serverSocketChannel` is an asynchronous socket channel that is used as a server-side socket to listen for incoming connections.
The `callback` function is executed whenever a new client connects to the server. This function is called for each connected client and is passed the `socketChannel` of the newly connected client.
In the `startListen` method, the server socket channel is set up to continuously listen for incoming connections. When a new client connects, the server socket channel returns the client's socket channel and the `callback` function is executed.

    listener.startConnectionListen(serverSocketChannel, socketChanne...
   
   
```sh
// Create a new InputListener to handle the ServerSocket input
InputListener listener2 = new InputListener();
```

`InputListener` is a class used to handle input coming from a socket. When creating a server socket, it's necessary for the server to be able to listen for connecting clients and handle the data sent by them. The InputListener class provides a way to do this, as it allows defining how to handle incoming data. In particular, the InputListener class implements the CompletionHandler interface, which is used to handle data asynchronously.

When a client sends data to the server, the data is read and handled by a CompletionHandler, which can be an instance of the InputListener class. InputListener defines a `handle` method, which is called every time a client sends data to the server. In this method, it's possible to define the logic to use for handling incoming data.
 ```sh
// Create an output listener to handle the server responses  
OutputListener listener = new OutputListener();
 ```
`OutputEventHandler` is a class used to handle output events generated by the server or client in a network application. The class is used to send data from the server or client to a recipient, such as another client or a storage device.

In particular, the OutputEventHandler class provides a way to handle asynchronously the output data generated by an instance of `AsynchronousSocketChannel`, which represents an asynchronous network socket. The class implements the `CompletionHandler` interface, which enables efficient handling of asynchronous output.

The `handle` method implemented by the class is called when the asynchronous output operation has been completed. In this method, it is possible to define the logic that you want to use to handle the output generated by the server or client, for example, to write the data to another socket or to save it to a storage device.
 ```sh
// Create an instance of the OutputListener which is an implementation of OutputEventHandler class and handle output 
new OutputListener<String>().handle(socketChannel, "hello", writeStringOutputEvent);
 ```
**Code example complete**
 ```sh
//Create Server  
AsynchronousServerSocketChannel serverSocketChannel;
try {
  serverSocketChannel = AsyncServerSocket.createServer(new InetSocketAddress(8080));
  //Start Listen Clients  
  Listener.getInstance().startConnectionListen(serverSocketChannel, socketChannel -> {
    System.out.println("Client Connected");
    InputListener listener2 = new InputListener();
    listener2.handle(socketChannel, new ResponseCallback() {
      @Override //You can replace Object with String or Primitives  
      public void complete(Object o) {
        System.out.println(o);
      }
    });
  });
} catch (IOException e) {
  e.printStackTrace();
}
```

**Getting Start with Client**

`AsyncSocket` is a class that provides a static method for creating a client connection using an AsynchronousSocketChannel. The main purpose of this class is to simplify the process of creating a client connection for a client application that wants to communicate with a server.

The `createClient` method is the main method of this class. It takes an `InetSocketAddress` as an input, which represents the address and port of the server that the client wants to connect to. The method opens an AsynchronousSocketChannel and connects to the specified server. The method returns the connected AsynchronousSocketChannel.

The method also throws IOException, ExecutionException, and InterruptedException if an I/O error occurs or if the current thread was interrupted while waiting for the connection to complete.

This method provides a convenient way for clients to connect to a server, without having to worry about the underlying details of opening and connecting a socket channel.
```sh
AsynchronousServerSocketChannel serverSocketChannel;  
try {  
  serverSocketChannel = AsyncServerSocket.createServer(new InetSocketAddress(8080));  
} catch (IOException e) {  
  e.printStackTrace();  
}
```

The `SocketThreadIO` class serves as a base for reading and writing data to a server using an `AsynchronousSocketChannel` and a `ByteBuffer`. This class provides the basic structure for implementing a reading or writing thread that utilizes asynchronous socket channels for communication.

An asynchronous socket channel is a type of network socket that allows for asynchronous communication, meaning that the socket can handle multiple incoming or outgoing connections at the same time without blocking the main thread. This is useful for implementing high-performance servers that can handle multiple connections simultaneously.

The `SocketThreadIO` class contains a single abstract method, `startThread()`, which must be implemented by subclasses. This method is called to start the reading or writing thread, and it is up to the subclass to determine the logic that will be executed in the thread.

```sh
try {
  // Create a new AsynchronousSocketChannel that connects to a server at localhost:8080  
  AsynchronousSocketChannel socketChannel = AsyncSocket.createClient(new InetSocketAddress("localhost", 8080));

  // Create a new OutputListener to handle the socket output  
  OutputListener listener = new OutputListener();

  // Create a new thread that will send 600 messages to the server  
  new Thread(() -> {
    for (int i = 0; i < 600; i++) {
      System.out.println("Test n " + i);
      // Send the message to the server using the OutputListener  
      listener.handle(socketChannel, "Test n " + i);
      try {
        Thread.sleep(3);
      } catch (InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }).start();

  // Create a new thread that will send 6000 messages to the server  
  new Thread(() -> {
    for (int i = 0; i < 6000; i++) {
      System.out.println(i);
      // Send the message to the server using the OutputListener  
      listener.handle(socketChannel, i);
      try {
        Thread.sleep(5);
      } catch (InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }).start();

} catch (IOException | ExecutionException | InterruptedException e) {
  e.printStackTrace();
}
```

 TODO:
 - I/O Custom Object

